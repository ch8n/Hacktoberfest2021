/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package Hacktoberfest2021

import kotlinx.css.*
import kotlinx.css.properties.border
import kotlinx.html.*
import kotlinx.html.stream.appendHTML
import org.intellij.markdown.flavours.commonmark.CommonMarkFlavourDescriptor
import org.intellij.markdown.html.HtmlGenerator
import org.intellij.markdown.parser.MarkdownParser
import java.io.File

data class Repository(
    val repository: Pair<String, String>,
    val issues: List<Issue>
)

data class Issue(
    val issue: Pair<String, String>,
    var language: MutableList<String> = mutableListOf()
)


class App {

    fun getIssueRepository(): List<Repository> {
        val markdownContent = File("explore/ISSUES.md").readText()
        val flavour = CommonMarkFlavourDescriptor()
        val parsedTree = MarkdownParser(flavour).buildMarkdownTreeFromString(markdownContent)
        val html = parsedTree.children.flatMap { it.children }
            .map { HtmlGenerator(markdownContent, it, flavour).generateHtml() }
            .filter { it.isNotEmpty() }
            .joinToString("\n")

        val repos = html.lines().filter { string ->
            (string.contains("<a") && !string.contains("/issues"))
        }

        val issues = html.lines().filter { string ->
            string.contains("/issues")
        }.map { parseLink(it) }

        val issueWithLang = issues.map { issue ->
            val lines = html.lines()
            val startIndex = lines.indexOfFirst { it.contains(issue.first) } + 1
            var endIndex = startIndex
            while (lines.getOrNull(endIndex)?.contains("<code>") == true) {
                endIndex += 1
            }
            val lang = (startIndex until endIndex).map {
                parseCode(lines.get(it))
            }
            Issue(issue, lang.toMutableList())
        }

        val repoLink = mutableListOf<Repository>()
        repos.forEach {
            val repoFormatted = parseLink(it)
            val exist = repoLink.firstOrNull { it.repository.first.contains(repoFormatted.first) }
            if (exist == null) {
                val repoIssues = issueWithLang.filter { it.issue.first.contains(repoFormatted.first) }
                repoLink.add(Repository(repoFormatted, repoIssues))
            }
        }
        return repoLink
    }

    fun getLanguages() = getIssueRepository().flatMap { it.issues }
        .flatMap { it.language }
        .map { it.toLowerCase() }
        .toSet()
        .toList()

    fun createOrGetDirectories(): List<File> {
        val language = getLanguages()
        val exploreDirectory = File("explore").absolutePath
        val directories = language.map {
            val folder = File("$exploreDirectory${File.separator}issues${File.separator}$it")
            if (!folder.exists()) {
                folder.mkdirs()
            }
            println(folder.absolutePath)
            return@map folder
        }
        return directories
    }

    fun generateMarkDown(directories: List<File>, repository: List<Repository>) {
        val stylesDir = File("explore/.meta")
        if (!stylesDir.exists()) {
            stylesDir.mkdirs()
        }
        val style = CssBuilder().apply {
            body {
                backgroundColor = Color("#f3f0e0")
                margin(20.px)
                padding(20.px)
            }

            table {
                padding(20.px)
                width = 100.pct
                borderCollapse = BorderCollapse.collapse
            }

            th {
                border(
                    width = 1.px,
                    style = BorderStyle.solid,
                    color = Color.black
                )
                textAlign = TextAlign.left
                margin(8.px)
                backgroundColor = Color("#dddddd")
                color = Color("#101010")
            }

            td {
                border(
                    width = 1.px,
                    style = BorderStyle.solid,
                    color = Color("#dddddd")
                )
                textAlign = TextAlign.left
                margin(8.px)
                color = Color("#008080")
            }

            em {
                margin(4.px)
            }

            (".center"){
                display = Display.block
                marginLeft = LinearDimension.auto
                marginRight = LinearDimension.auto
                width = 50.pct
            }

        }.toString()
        File(stylesDir.absolutePath + "${File.separator}style.css").writeText(style)
        directories.forEach {
            val html = buildString {
                appendHTML(false).html {
                    appendLine("<!DOCTYPE html>")
                    head {
                        title {
                            +"Hacktoberfest 2021 Issues"
                        }
                        link {
                            href = "../../.meta/style.css"
                            rel = "stylesheet"
                        }
                    }
                    body {
                        img {
                            src = "../../.meta/logo.png"
                            classes = setOf("center")
                        }
                        h1 { +it.nameWithoutExtension.capitalize() }
                        h4 {
                            em { +"This is a generated file from " }
                            a {
                                href = "../../ISSUES.md"
                                +"ISSUES"
                            }
                            em { +" kindly don't delete it" }
                            em {
                                +"- Automation script by "
                                a {
                                    href = "https://chetangupta.net/about"
                                    target = "_blank"
                                    +"Chetan Gupta"
                                }
                            }
                        }
                        table {
                            tr {
                                th { +"Serial No." }
                                th { +"Issue" }
                                th { +"Repository" }
                                th { +"Language" }
                            }
                            val issues = mutableListOf<Pair<Issue, Repository>>()
                            val filename = it.nameWithoutExtension
                            repository.forEachIndexed { index, repo ->
                                repo.issues.fold(issues) { acc, _issue ->
                                    val belongs = filename in _issue.language.map { it.toLowerCase() }
                                    if (belongs) {
                                        acc.add(_issue to repo)
                                    }
                                    return@fold acc
                                }
                            }

                            issues.forEachIndexed { index, _issue ->
                                val (issueUrl, issueName) = _issue.first.issue
                                tr {
                                    td {
                                        +"${index + 1}"
                                    }
                                    td {
                                        a {
                                            href = issueUrl
                                            target = "_blank"
                                            +issueName
                                        }
                                    }
                                    td {
                                        a {
                                            val (repoUrl, repoName) = _issue.second.repository
                                            href = repoUrl
                                            target = "_blank"
                                            +repoName
                                        }
                                    }
                                    td {
                                        _issue.first.language.forEach {
                                            em { +it }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            File(it.absolutePath + "${File.separator}index.html").writeText(html)
        }
    }

    fun generateExploreMarkDown(directories: List<File>) {
        val html = buildString {
            appendHTML(false).html {
                appendLine("<!DOCTYPE html>")
                head {
                    title {
                        +"Hacktoberfest 2021 Explor"
                    }
                    link {
                        href = ".meta/style.css"
                        rel = "stylesheet"
                    }
                }
                body {
                    img {
                        src = ".meta/logo.png"
                        classes = setOf("center")
                    }
                    h4 {
                        em { +"This is a generated file from " }
                        a {
                            href = "../../ISSUES.md"
                            +"ISSUES"
                        }
                        em { +" kindly don't delete it" }
                        em {
                            +"- Automation script by "
                            a {
                                href = "https://chetangupta.net/about"
                                target = "_blank"
                                +"Chetan Gupta"
                            }
                        }
                    }
                    table {
                        tr {
                            th { +"Serial No." }
                            th { +"Technology" }
                        }
                        directories.forEachIndexed { index, file ->
                            tr {
                                td {
                                    +"${index + 1}"
                                }
                                td {
                                    a {
                                        href = file.path
                                        target = "_blank"
                                        +file.nameWithoutExtension.capitalize()
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        File("explore/explore.html").writeText(html)
    }
}

fun main() {
    val app = App()
    val repos = app.getIssueRepository()
    val directories = app.createOrGetDirectories()
    app.generateMarkDown(directories, repos)
    app.generateExploreMarkDown(directories)
}

fun parseLink(input: String): Pair<String, String> {
    val (_, sec) = input.split("href=\"")
    val (thir, four) = sec.split("\">")
    val (five, _) = four.split("</a>")
    return thir to five
}

fun parseCode(input: String): String {
    val (first, sec) = input.split("<code>")
    val (third, fourth) = sec.split("</code>")
    return third
}

