/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package Hacktoberfest2021

import org.intellij.markdown.flavours.commonmark.CommonMarkFlavourDescriptor
import org.intellij.markdown.html.HtmlGenerator
import org.intellij.markdown.parser.MarkdownParser
import java.io.File

data class Repository(
    val repository: Pair<String, String>,
    val issues: List<Issue>
)

data class Issue(
    val issue: Pair<String, String>,
    var language: MutableList<String> = mutableListOf()
)


class App {
    fun getIssueRepository(): List<Repository> {
        val markdownContent = File("explore/ISSUES.md").readText()
        val flavour = CommonMarkFlavourDescriptor()
        val parsedTree = MarkdownParser(flavour).buildMarkdownTreeFromString(markdownContent)
        val html = parsedTree.children.flatMap { it.children }
            .map { HtmlGenerator(markdownContent, it, flavour).generateHtml() }
            .filter { it.isNotEmpty() }
            .joinToString("\n")

        val repos = html.lines().filter { string ->
            (string.contains("<a") && !string.contains("/issues"))
        }

        val issues = html.lines().filter { string ->
            string.contains("/issues")
        }.map { parseLink(it) }

        val issueWithLang = issues.map { issue ->
            val lines = html.lines()
            val startIndex = lines.indexOfFirst { it.contains(issue.first) } + 1
            var endIndex = startIndex
            while (lines.getOrNull(endIndex)?.contains("<code>") == true) {
                endIndex += 1
            }
            val lang = (startIndex until endIndex).map {
                parseCode(lines.get(it))
            }
            Issue(issue, lang.toMutableList())
        }

        val repoLink = mutableListOf<Repository>()
        repos.forEach {
            val repoFormatted = parseLink(it)
            val exist = repoLink.firstOrNull { it.repository.first.contains(repoFormatted.first) }
            if (exist == null) {
                val repoIssues = issueWithLang.filter { it.issue.first.contains(repoFormatted.first) }
                repoLink.add(Repository(repoFormatted, repoIssues))
            }
        }
        return repoLink
    }

    fun getLanguages() = getIssueRepository().flatMap { it.issues }
        .flatMap { it.language }
        .map { it.toLowerCase() }
        .map { lang ->
            return@map when {
                lang.contains("js") || lang.contains("ecma") || lang.contains("javascript") -> "javascript"
                lang.contains("ts") || lang.contains("typescript") -> "typescript"
                lang.contains("node") -> "nodejs"
                lang.contains("react") -> "react + react-native"
                else -> lang
            }
        }
        .toSet()
        .toList()

    fun createOrGetDirectories(): List<File> {
        val language = getLanguages()
        val exploreDirectory = File("explore").absolutePath
        val directories = language.map {
            val folder = File("$exploreDirectory${File.separator}issues${File.separator}$it")
            if (!folder.exists()) {
                folder.mkdirs()
            }
            println(folder.absolutePath)
            return@map folder
        }
        return directories
    }

    fun generateMarkDown(directories: List<File>, repository: List<Repository>) {

    }
}

fun main() {
    val app = App()
    val repos = app.getIssueRepository()
    val directories = app.createOrGetDirectories()
    app.generateMarkDown(directories, repos)
}

fun parseLink(input: String): Pair<String, String> {
    val (_, sec) = input.split("href=\"")
    val (thir, four) = sec.split("\">")
    val (five, _) = four.split("</a>")
    return thir to five
}

fun parseCode(input: String): String {
    val (first, sec) = input.split("<code>")
    val (third, fourth) = sec.split("</code>")
    return third
}